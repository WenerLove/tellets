package tellets
import (
	"time"
	"errors"
)

type MetaParser interface {
	Parse(string) (*Meta, error)
	CanParse(filename string) bool
	Name() string
}

var MetaParserManager = createMetaParserManager()
func createMetaParserManager() *metaParserManager {
	mgr := &metaParserManager{
		make(map[string]MetaParser),
	}

	return mgr
}
type metaParserManager struct {
	parsers map[string]MetaParser
}
func (mgr *metaParserManager)Register(p MetaParser) error {
	if p.Name() == "" {
		return errors.New("Parser must have a name")
	}
	if _, exists := mgr.parsers[p.Name()]; exists {
		return errors.New("Parser with same name already exists")
	}
	mgr.parsers[p.Name()] = p
	log.Info("Register parser %s", p.Name())
	return nil
}

func (mgr *metaParserManager)Parser(name string) MetaParser {
	return mgr.parsers[name]
}
func (mgr *metaParserManager)Parse(fn, content string) (m *Meta, err error) {
	for n, p := range mgr.parsers {
		if !p.CanParse(fn) {continue}
		m, err=p.Parse(content)
		if err != nil {
			log.Error("Use %s to parse %s failed: %s", n, fn, err)
		}
	}
	return nil, errors.New("No parser can parse "+fn)
}

type Meta struct {
	// Required
	Title string
	Categories []string
	Tags []string
	Date *time.Time
	LastModifiedDate *time.Time
	State string
	// Generated by title
	Link string
	PermLink string
	Features []string
	Format string
	// Key to find an article
	Sha1 string
	// wener<wener@wener.me>(http://hi.wener.me)
	Author []string
	// Optional option
	Option map[string]string
	Summary string
}
type ArticleState string
type ContentFormat string
type Feature string

const (
	PUBLISHED   ArticleState = "PUBLISHED"
	DRAFT       ArticleState = "DRAFT"
)

type MetaStorage interface {
	FindBySha(string) Meta
	FindByLink(string) Meta
	FindByTags([]string) []Meta
	FindByCategories([]string) []Meta
	Content(string) string
	Store(*Meta, string)
	Remove(*Meta)
}

