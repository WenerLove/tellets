package tellets
import (
	"net/url"
	"time"
	"github.com/jinzhu/gorm"
	"bytes"
	"errors"
)

// Parser can not parse, will try next
var ErrCanNotParse = errors.New("Can not parse")
// Collector can not collect, will try next
var ErrCanNotCollect = errors.New("Can not collect")


type Tellets interface {
	Option() TelletsOption
	Storage() Storage
	Hook() Hook
	Context() Context
}
type Storage interface {
	DB() gorm.DB
	TableName(string) string
	Store(interface{}) error
}

type TelletsOption struct {
	Storage StorageOption
}
type StorageOption struct {
	Dialect         string
	Arguments       []interface{}
	TableNamePrefix string
	TableNameSuffix string
}
const (
	HookTelletsInit HookType = "TelletsInit"
	HookCollectorInit = "CollectorInit"
	HookParserInit = "ParserInit"
	HookAPIInit = "APIInit"
	HookParse = "Parse"
	HookCollect = "Collect"
)

type DataServer interface {
	Tellets() Tellets
	Hook() Hook
	Context() Context
}

type CollectServer interface {
	Tellets() Tellets
	Hook() Hook
	Context() Context
	Collect(*url.URL) ([]Collection, error)
	Parse(*Collection) (*Meta, error)
	// Discover url, collection or meta
	Discover(interface{})
}

type Parser interface {
	Parse(*Collection) (*Meta, error)
}

type Collector interface {
	Collect(*url.URL) ([]Collection, error)
}

type Named interface {
	Name() string
}

type Initializable interface {
	// return init function
	Init() interface{}
}

type Collection struct {
	// Filename
	Filename string
	Content  string
	From     *url.URL
	Attrs    map[string]string
}

type Category struct {
	Name string
}
type Tag struct {
	Name string
}

type Author struct {
	Name    string `json:"name,omitempty"`
	Email   string `json:"email,omitempty"`
	Website string `json:"website,omitempty"`
}

func (a Author)ToString() string {
	buf := bytes.NewBufferString("")
	if a.Name != "" {buf.WriteString(a.Name)}
	if a.Email != "" {buf.WriteString("<"+a.Email+">")}
	if a.Website != "" {buf.WriteString("("+a.Name+")")}
	return buf.String()
}
type Article struct {
	// Required
	Title            string
	Categories       []Category
	Tags             []Tag
	Date             *time.Time
	LastModifiedDate *time.Time
	State            ArticleState
	// Optional, Generated by title
	Link             string
	PermLink         string
	Features         []string
	Format           string
	// Key to find an article
	Hash             string
	// Format is wener<wener@wener.me>(http://hi.wener.me)
	Authors          []Author
	// Optional option
	Option           Option
	Intro            string
	Content          string
}

type ArticleState string
type ContentFormat string
type Feature string

const (
	ARTICLE_PUBLISHED   ArticleState = "PUBLISHED"
	ARTICLE_DRAFT       ArticleState = "DRAFT"
)
const (
	FORMAT_HTML   ContentFormat = "HTML"
	FORMAT_MARKDOWN       ContentFormat = "MARKDOWN"
)

func RegisterCollector(f func() Collector) {
	RegisterPlugin(func(t Tellets) {
		t.Hook().HookAfter(HookCollectorInit, func(svr CollectServer, s *[]Collector) {
			p := f()
			if i, ok := p.(Initializable); ok {
				svr.Context().Call(i.Init())
			}
			*s = append(*s, p)
		})
	})
}

func RegisterParser(f func() Parser) {
	RegisterPlugin(func(t Tellets) {
		t.Hook().HookAfter(HookCollectorInit, func(svr CollectServer, s *[]Parser) {
			p := f()
			if i, ok := p.(Initializable); ok {
				svr.Context().Call(i.Init())
			}
			*s = append(*s, p)
		})
	})
}
var plugins = make([]func(Tellets), 0)
func RegisterPlugin(f func(Tellets)) {
	plugins = append(plugins, f)
}

func NewDataServer(t Tellets) DataServer {
	return nil
}
func NewCollectionServer(t Tellets) CollectServer {
	return nil
}

type Meta struct {
	// Required
	Title            string
	Categories       []string
	Tags             []string
	Date             *time.Time
	LastModifiedDate *time.Time
	State            string
	// Optional, Generated by title
	Link             string
	PermLink         string
	Features         []string
	Format           string
	// Key to find an article
	Hash             string
	// Format is wener<wener@wener.me>(http://hi.wener.me)
	Authors          []string
	// Optional option
	Option           Option
	Intro            string
	Content          string
}