package tellets
import (
	"time"
	"database/sql"
	"bytes"
	"net/url"
)

type Meta struct {
	// Required
	Title            string
	Categories       []string
	Tags             []string
	Date             *time.Time
	LastModifiedDate *time.Time
	State            string
	// Optional, Generated by title
	Link             string
	PermLink         string
	Features         []string
	Format           string
	// Key to find an article
	Hash             string
	// Format is wener<wener@wener.me>(http://hi.wener.me)
	Authors          []string
	// Optional option
	Option           Option
	Intro            string
	Content          string
}
type Collection struct {
	// Filename
	Filename string
	Content  string
	From     *url.URL
	Attrs    map[string]string
}

type Category struct {
	Id          string
	Name        string
	Description string
	Language    string
}

type Tag struct {
	Id          string
	Name        string
	Description string
	Language    string
}

type Author struct {
	Code    string `gorm:"primary_key"`
	Name    string
	Email   string `sql:"type:varchar(100);unique_index"`
	Website string
}

func (a Author)ToString() string {
	buf := bytes.NewBufferString("")
	if a.Name != "" {
		buf.WriteString(a.Name)
	}else {
		buf.WriteString(a.Code)
	}
	if a.Email != "" {buf.WriteString("<"+a.Email+">")}
	if a.Website != "" {buf.WriteString("("+a.Name+")")}
	return buf.String()
}

type ArticleState string
type ContentFormat string
type Feature string

const (
	ARTICLE_PUBLISHED   ArticleState = "PUBLISHED"
	ARTICLE_DRAFT       ArticleState = "DRAFT"
)
const (
	FORMAT_HTML   ContentFormat = "HTML"
	FORMAT_MARKDOWN       ContentFormat = "MARKDOWN"
)


type Post struct {
	PermLink     string `gorm:"primary_key"`
	Link         string
	Source       string `sql:"not null;unique"`
	Title        string
	Language     string
	Intro        string `sql:"size:1024"`
	Content      string `sql:"type:varchar(100000)"`        // ~100k
	Format       string                                     // 文章格式, markdown,html,slide...
	Hash         string

	Categories   []Category `gorm:"many2many:post_category;"`
	Tags         []Tag      `gorm:"many2many:post_tag;"`
	Authors      []Author   `gorm:"many2many:post_author;"` // Format is wener<wener@wener.me>(http://hi.wener.me)

	PublishDate  *time.Time
	ModifiedDate *time.Time

	CreatedAt    time.Time
	UpdatedAt    time.Time
	DeletedAt    *time.Time
}


type User struct {
	ID                int
	Birthday          time.Time
	Age               int
	Name              string  `sql:"size:255"`                      // Default size for string is 255, you could reset it with this tag
	Num               int     `sql:"AUTO_INCREMENT"`
	CreatedAt         time.Time
	UpdatedAt         time.Time
	DeletedAt         *time.Time

	Emails            []Email                                       // One-To-Many relationship (has many)
	BillingAddress    Address                                       // One-To-One relationship (has one)
	BillingAddressID  sql.NullInt64                                 // Foreign key of BillingAddress
	ShippingAddress   Address                                       // One-To-One relationship (has one)
	ShippingAddressID int                                           // Foreign key of ShippingAddress
	IgnoreMe          int `sql:"-"`                                 // Ignore this field
	Languages         []Language `gorm:"many2many:user_languages;"` // Many-To-Many relationship, 'user_languages' is join table
}

type Email struct {
	ID         int
	UserID     int     `sql:"index"`                          // Foreign key (belongs to), tag `index` will create index for this field when using AutoMigrate
	Email      string  `sql:"type:varchar(100);unique_index"` // Set field's sql type, tag `unique_index` will create unique index
	Subscribed bool
}

type Address struct {
	ID       int
	Address1 string         `sql:"not null;unique"` // Set field as not nullable and unique
	Address2 string         `sql:"type:varchar(100);unique"`
	Post     sql.NullString `sql:"not null"`
}

type Language struct {
	ID   int
	Name string `sql:"index:idx_name_code"` // Create index with name, and will create combined index if find other fields defined same name
	Code string `sql:"index:idx_name_code"` // `unique_index` also works
}